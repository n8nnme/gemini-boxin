#!/bin/bash
# ======================================================================
# Certbot Renewal Hook Script Template
# Generated by: deploy_proxy_platform.sh
# Purpose: Process renewed certificates and reload/restart necessary services.
# Location: /etc/letsencrypt/renewal-hooks/deploy/process_certs_and_reload.sh
# ======================================================================

# Exit immediately if a command exits with a non-zero status.
set -euo pipefail

# --- Configuration Variables (Passed from deploy script) ---
# These variables are baked into the script when it's created by deploy_proxy_platform.sh
HAPROXY_CERT_DIR="${HAPROXY_CERT_DIR}"
HAPROXY_GROUP="${HAPROXY_GROUP}"
SINGBOX_CERT_DIR="${SINGBOX_CERT_DIR}"
SINGBOX_USER="${SINGBOX_USER}"
SINGBOX_GROUP="${SINGBOX_GROUP}"
LETSENCRYPT_LIVE_DIR="${LETSENCRYPT_LIVE_DIR}"
MAIN_DOMAIN="${MAIN_DOMAIN}"
SUBSCRIPTION_DOMAIN="${SUBSCRIPTION_DOMAIN}"

# --- Logging Helper ---
# Logs messages clearly identifying them as coming from this hook.
# Uses systemd-cat for integration with journald if available, otherwise falls back to logger.
log_hook() {
    local level="$1" # e.g., notice, err, warning, info
    local message="$2"
    local tag="certbot-hook"

    if command -v systemd-cat >/dev/null; then
        # Log using systemd-cat with appropriate priority level
        echo "[CERT-HOOK] ${message}" | systemd-cat -t "${tag}" -p "${level}"
    else
        # Fallback to logger utility
        logger -t "${tag}" -p "daemon.${level}" "[CERT-HOOK] ${message}"
    fi
}

# --- Certificate Processing Function ---
# Processes certificates for a specific domain and purpose (HAProxy or Sing-Box).
# Handles copying/combining files, setting ownership/permissions atomically.
# Returns 0 on success, 1 on failure.
process_cert() {
    local domain="$1"
    local purpose="$2" # "haproxy" or "singbox"
    local success=0

    log_hook info "Processing certificate renewal for ${domain} (Purpose: ${purpose})..."

    # Standard paths within the 'live' directory for the domain
    local live_fullchain_path="${LETSENCRYPT_LIVE_DIR}/${domain}/fullchain.pem"
    local live_privkey_path="${LETSENCRYPT_LIVE_DIR}/${domain}/privkey.pem"

    # Certbot sets RENEWED_LINEAGE environment variable containing the path
    # of the renewed certificate lineage. Check if this domain was actually renewed.
    if [[ -z "${RENEWED_LINEAGE:-}" ]] || [[ "${RENEWED_LINEAGE}" != *"${domain}"* ]]; then
         log_hook info "Certificate for ${domain} not part of this renewal event (RENEWED_LINEAGE='${RENEWED_LINEAGE:-}'). Skipping."
         return 0 # Not an error, just skip processing this domain
    fi

    # Verify source files exist (should always exist if RENEWED_LINEAGE is set, but check anyway)
    if [[ ! -f "${live_fullchain_path}" || ! -f "${live_privkey_path}" ]]; then
        log_hook warning "Missing renewed certificate files for ${domain} in ${LETSENCRYPT_LIVE_DIR}. Skipping processing for ${purpose}."
        return 1 # Indicate failure
    fi

    # Use temporary files for atomic replace operations
    local tmp_cert; tmp_cert=$(mktemp)
    local tmp_key; tmp_key=$(mktemp)
    local tmp_combined; tmp_combined=$(mktemp)
    # Ensure temporary files are removed on function exit (success or failure)
    trap 'rm -f "${tmp_cert}" "${tmp_key}" "${tmp_combined}"' RETURN

    # Process based on purpose
    if [[ "${purpose}" == "haproxy" ]]; then
        local combined_pem_path="${HAPROXY_CERT_DIR}/${domain}.pem"
        log_hook info "Combining renewed certs for HAProxy: ${combined_pem_path}"
        # Combine cert+key into temp file, set perms/owner, then move into place
        cat "${live_fullchain_path}" "${live_privkey_path}" > "${tmp_combined}" && \
            chown root:"${HAPROXY_GROUP}" "${tmp_combined}" && \
            chmod 640 "${tmp_combined}" && \
            mv -f "${tmp_combined}" "${combined_pem_path}" && success=1 || \
            log_hook err "Failed processing HAProxy cert for ${domain}. Check permissions on ${HAPROXY_CERT_DIR}."

    elif [[ "${purpose}" == "singbox" ]]; then
        # Assuming the main domain's certificate is used for Hysteria2
        local cert_path="${SINGBOX_CERT_DIR}/hysteria2.cert.pem"
        local key_path="${SINGBOX_CERT_DIR}/hysteria2.key.pem"
        log_hook info "Copying renewed certs for Sing-Box: ${cert_path}, ${key_path}"
        # Copy cert and key to temp files, set perms/owner, then move into place
        cp "${live_fullchain_path}" "${tmp_cert}" && \
            cp "${live_privkey_path}" "${tmp_key}" && \
            chown "${SINGBOX_USER}":"${SINGBOX_GROUP}" "${tmp_cert}" "${tmp_key}" && \
            chmod 640 "${tmp_cert}" "${tmp_key}" && \
            mv -f "${tmp_cert}" "${cert_path}" && \
            mv -f "${tmp_key}" "${key_path}" && success=1 || \
            log_hook err "Failed processing Sing-Box certs from ${domain}. Check permissions on ${SINGBOX_CERT_DIR}."
    else
        log_hook warning "Unknown purpose '${purpose}' for domain ${domain}."
        return 1 # Unknown purpose is an error
    fi

    # Return 0 if successful (bash success), 1 if failed
    [[ $success -eq 1 ]]; return $?
}

# --- Main Hook Logic ---
log_hook notice "Certbot renewal hook started."
HAD_ERRORS=0
HAPROXY_NEEDS_RELOAD=0
SINGBOX_NEEDS_RESTART=0 # Sing-Box generally needs a restart to pick up new cert file content

# Process certificates for each domain and purpose
# If processing fails for any, set HAD_ERRORS=1
# If processing succeeds for a specific service, mark it for reload/restart
process_cert "${MAIN_DOMAIN}" "haproxy" && HAPROXY_NEEDS_RELOAD=1 || HAD_ERRORS=1
process_cert "${MAIN_DOMAIN}" "singbox" && SINGBOX_NEEDS_RESTART=1 || HAD_ERRORS=1
process_cert "${SUBSCRIPTION_DOMAIN}" "haproxy" && HAPROXY_NEEDS_RELOAD=1 || HAD_ERRORS=1

# Reload/Restart services only if ALL certificate processing steps succeeded
if [[ $HAD_ERRORS -eq 0 ]]; then
    log_hook notice "Certificate processing completed successfully."
    # Reload HAProxy if its certificates were updated
    if [[ $HAPROXY_NEEDS_RELOAD -eq 1 ]]; then
        log_hook notice "Reloading HAProxy service..."
        if systemctl reload haproxy; then
            log_hook notice "HAProxy reloaded successfully."
        else
            log_hook err "Failed to reload HAProxy service. Check 'systemctl status haproxy' and HAProxy logs."
        fi
    fi
    # Restart Sing-Box if its certificates were updated
    if [[ $SINGBOX_NEEDS_RESTART -eq 1 ]]; then
        log_hook notice "Restarting Sing-Box service..."
        if systemctl restart sing-box; then
            log_hook notice "Sing-Box restarted successfully."
        else
            log_hook err "Failed to restart Sing-Box service. Check 'systemctl status sing-box' and Sing-Box logs."
        fi
    fi
else
    log_hook warning "Errors occurred during certificate processing. Service reload/restart skipped to avoid issues."
fi

log_hook notice "Certbot renewal hook finished."
exit 0
